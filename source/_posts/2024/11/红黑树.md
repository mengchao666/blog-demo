---
title: çº¢é»‘æ ‘
tags: [kernel]
categories: [kernel]
permalink: 
poster:
  topic: null
  headline: null
  caption: null
  color: null
date: 2024-11-25 22:59:37
topic: linux_kernel
description:
cover:
banner:
references:
---
### ä¸€ã€ çº¢é»‘æ ‘çš„åŸç†

çº¢é»‘æ ‘RB Treeæ˜¯äºŒå‰æ ‘çš„ä¸€ç§ï¼Œä½œä¸ºä¸€ç§è‡ªå¹³è¡¡äºŒå‰æ ‘ï¼ˆä¸€äº›æƒ…å†µä¸‹ä¸æ˜¯å®Œå…¨å¹³è¡¡çš„ï¼‰ï¼Œå®ƒåœ¨æœ€åçš„æƒ…å†µä¸‹æŸ¥è¯¢å¤æ‚åº¦ä¸ºO(logN)ğ‘‚(ğ‘™ğ‘œğ‘”ğ‘)ã€‚ä¸AVLæ ‘ç±»ä¼¼ï¼Œå°½ç®¡RB TreeæŸ¥è¯¢æ•ˆç‡ä¸å¦‚AVLæ ‘ï¼ˆå› ä¸ºRB Treeå·¦å³å­æ ‘é«˜åº¦å·®è·æœ€å¤šæ¥è¿‘ä¸¤å€ï¼Œè€ŒAVLæ ‘å§‹ç»ˆä¿æŒå·¦å³å­æ ‘é«˜åº¦æœ€å¤šä¸è¶…è¿‡1ï¼‰ï¼Œä½†å…¶æ’å…¥åˆ é™¤æ•ˆç‡é«˜ï¼Œé€‚åˆç”¨äºå¤§æ•°æ®é‡ä¸”æ›´æ–°é¢‘ç¹çš„åœºæ™¯ï¼Œä¾‹å¦‚å†…æ ¸IOè°ƒåº¦ç®—æ³•ã€‚<br />çº¢é»‘æ ‘åœ¨äºŒå‰æ ‘çš„åŸºç¡€ä¸Šåšäº†å¦‚ä¸‹çº¦æŸï¼š

1. æ ‘ç§å…¨éƒ¨èŠ‚ç‚¹è¦ä¹ˆæ˜¯é»‘è‰²è¦ä¹ˆæ˜¯çº¢è‰²
2. æ ‘çš„æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²çš„
3. å¶èŠ‚ç‚¹ï¼ˆæŒ‡NULLèŠ‚ç‚¹ï¼‰é¢œè‰²ä¸ºé»‘è‰²
4. çº¢è‰²èŠ‚ç‚¹ä¹‹é—´ä¸èƒ½ç›¸é‚»
5. ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘é«˜åº¦ï¼ˆåªç»Ÿè®¡é»‘è‰²èŠ‚ç‚¹ï¼‰ç›¸åŒ

åœ¨ä»‹ç»çº¢é»‘æ ‘çš„æ“ä½œå‰ï¼Œæˆ‘ä»¬å…ˆè¯´æ˜ä»¥ä¸‹å‡ ç‚¹æƒ¯ä¾‹ï¼š

* ==æ‰€æœ‰èŠ‚ç‚¹åœ¨æ’å…¥çš„æ—¶å€™éƒ½å°†æ˜¯çº¢è‰²èŠ‚ç‚¹ï¼ˆä¸åŒ…æ‹¬æ ¹èŠ‚ç‚¹ï¼Œå…¶æ’å…¥æ—¶æ˜¯é»‘è‰²çš„ï¼‰==ï¼Œè¿™æ ·æœ‰ä¸€ä¸ªå¥½å¤„æ˜¯å¯ä»¥ä¸è¿åçº¦æŸ1ï¼Œ2ï¼Œ3å’Œ5ï¼Œå¯¹äºçº¦æŸ1ï¼Œ2å’Œ3æ˜¯æ˜¾ç„¶çš„ï¼Œå¯¹äº5ï¼Œç”±äºæ·»åŠ çº¢è‰²èŠ‚ç‚¹å¹¶ä¸ä¼šå½±å“å…¶çˆ¶èŠ‚ç‚¹åŠä»¥ä¸ŠèŠ‚ç‚¹å·¦å³å­æ ‘é»‘è‰²èŠ‚ç‚¹æ•°é‡ï¼Œæ•…ä¸è¿åçº¦æŸ5ã€‚å› æ­¤ï¼Œåœ¨æ’å…¥èŠ‚ç‚¹åï¼Œåªéœ€åˆ¤æ–­æ˜¯å¦è¿åçº¦æŸ4ã€‚
* ==ä¸€é¢—çº¢é»‘æ ‘ä¸­ï¼ŒæŸä¸€èŠ‚ç‚¹å·¦å³å­æ ‘èŠ‚ç‚¹é«˜åº¦å·®ä¸ä¼šè¶…è¿‡2å€==ï¼Œè€ƒè™‘ä¸€ç§æé™æƒ…å†µï¼šå·¦å­æ ‘é»‘è‰²èŠ‚ç‚¹é«˜åº¦ä¸ºxï¼Œä¸”æœ€é•¿è·¯å¾„ä¸­ä¸å­˜åœ¨çº¢è‰²èŠ‚ç‚¹ï¼Œè¿™æ˜¯å…è®¸çš„ï¼Œå³å­æ ‘æœ‰é»‘è‰²èŠ‚ç‚¹é«˜åº¦ä¸ºxï¼Œè¿™æ ·æ»¡è¶³çº¦æŸ5ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå³å­æ ‘æœ€é•¿è·¯å¾„é»‘è‰²å‡ ç‚¹ä¹‹é—´éƒ½ç”±çº¢è‰²èŠ‚ç‚¹éš”å¼€ï¼ˆæ»¡è¶³çº¦æŸ4ï¼‰ï¼Œæ•…å³å­æ ‘æ€»é«˜åº¦ä¸º2x-1ï¼Œçº¦ç­‰äº2xã€‚

### äºŒã€çº¢é»‘æ ‘æ“ä½œ

åœ¨Linuxå†…æ ¸ä»£ç ä¸­ä»…æä¾›äº†çº¢é»‘æ ‘èŠ‚ç‚¹é“¾æ¥ã€ç´¢å¼•ã€è°ƒæ•´ã€åˆ é™¤ç­‰åŸºç¡€æ“ä½œï¼Œä¸åŒ…å«ç‰¹å®šå«ä¹‰çš„æŸ¥è¯¢ã€æ’å…¥ç­‰æ“ä½œï¼š

* `void rb_insert_color(struct rb_node *, struct rb_root *);`ï¼Œæ£€æŸ¥è°ƒæ•´ä¸€ä¸ªæŒ‡å®šèŠ‚ç‚¹ï¼Œé€šå¸¸ä¸`rb_link_node`æ­é…ä½¿ç”¨ï¼›
* `void rb_erase(struct rb_node *, struct rb_root *);`ï¼Œä»æ ‘ä¸­åˆ é™¤ä¸€ä¸ªæŒ‡å®šèŠ‚ç‚¹ï¼›
* `struct rb_node *rb_next(struct rb_node *);`ï¼Œè¿”å›ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆé¡ºåºçš„ï¼‰ï¼›
* `struct rb_node *rb_prev(struct rb_node *);`ï¼Œè¿”å›ä¸€ä¸ªèŠ‚ç‚¹çš„ä¸Šä¸€ä¸ªèŠ‚ç‚¹ï¼ˆé¡ºåºçš„ï¼‰ï¼›
* `struct rb_node *rb_first(struct rb_root *);`ï¼Œè¿”å›æ ‘ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆé¡ºåºçš„ï¼‰ï¼›
* `struct rb_node *rb_last(struct rb_root *);`ï¼Œè¿”å›æ ‘ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼ˆé¡ºåºçš„ï¼‰ï¼›
* `void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);`ï¼Œç”¨`new`æ›¿æ¢èŠ‚ç‚¹`victim`ï¼›
* `inline void rb_link_node(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)`ï¼Œå°†ä¸€ä¸ªèŠ‚ç‚¹é“¾æ¥åˆ°æ ‘ä¸­æŒ‡å®šä½ç½®ï¼Œ`parent`æ˜¯çˆ¶èŠ‚ç‚¹ï¼Œ`rb_link`æŒ‡å®šäº†é“¾æ¥çˆ¶èŠ‚ç‚¹çš„ä½ç½®æ˜¯å·¦è¿˜æ˜¯å³ã€‚

#### 2.1 çº¢é»‘æ ‘çš„èŠ‚ç‚¹æ’å…¥

æ ¹æ®ç¬¬ä¸€ä¸ªéƒ¨åˆ†æˆ‘ä»¬æ‰€è®²çš„å†…å®¹å¯çŸ¥ï¼Œä¸€ä¸ªèŠ‚ç‚¹æ’å…¥RB Treeæ—¶ä¼šè¢«æŸ“æˆçº¢è‰²ï¼Œå› æ­¤åªéœ€è¦æ£€æŸ¥æ’å…¥æ—¶æ˜¯å¦è¿åè§„åˆ™4ï¼Œæ—¢æ’å…¥èŠ‚ç‚¹ä¸å…¶çˆ¶èŠ‚ç‚¹æ˜¯å¦éƒ½æ˜¯çº¢è‰²ï¼Œç„¶ååšå‡ºç›¸åº”çš„è°ƒæ•´ï¼Œè¿™äº›å·¥ä½œç”±`rb_insert_color`å‡½æ•°å®Œæˆï¼Œå…¶ä¸»è¦åˆ†ä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼Œç¬¬ä¸€ç§æ˜¯çˆ¶èŠ‚ç‚¹ä¸ºé»‘è‰²ï¼Œé‚£ä¹ˆä¸éœ€è¦åšä»»ä½•äº‹æƒ…ï¼Œæ’å…¥çº¢èŠ‚ç‚¹åè¯¥æ ‘ä»ç„¶ç¬¦åˆæ‰€æœ‰è§„åˆ™ã€‚

```c
void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *parent, *gparent;

    while ((parent = node->rb_parent) && parent->rb_color == RB_RED)
    {
        ... // æ£€æŸ¥ä¸å¤„ç†
    }

    root->rb_node->rb_color = RB_BLACK; // ä¿è¯æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²çš„
}
```

ç”±ä»£ç å¯çŸ¥ï¼Œåªè¦çˆ¶èŠ‚ç‚¹ä¸ºé»‘è‰²é‚£ä¹ˆå¯ä»¥ç›´æ¥é€€å‡ºã€‚ç¬¬äºŒç§æƒ…å†µæ˜¯çˆ¶èŠ‚ç‚¹ä¸ºçº¢è‰²ï¼Œæ­¤æ—¶è¿åè§„åˆ™4ï¼Œä½†æ˜¯å…¶å”çˆ¶èŠ‚ç‚¹ï¼ˆçˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„å¦ä¸€ä¸ªå­èŠ‚ç‚¹ï¼‰ä¹Ÿæ˜¯çº¢è‰²ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå·¦è¾¹å››ä¸ªæ ‘åŒ…å«äº†å…¨éƒ¨è¿™ç§æƒ…å†µï¼ŒAæ˜¯ç¥–çˆ¶ï¼ŒBæ˜¯æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ŒEæ˜¯æ’å…¥èŠ‚ç‚¹ã€‚<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240324144319658-1183105020.png)

è¿™ç§æƒ…å†µä¸‹ï¼Œå¯ä»¥ç›´æ¥å°†çˆ¶èŠ‚ç‚¹å’Œå”çˆ¶èŠ‚ç‚¹æŸ“æˆé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹æŸ“æˆçº¢è‰²ï¼Œè¿™æ ·æ’å…¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹è§£å†³äº†è§„åˆ™4ï¼ŒåŒæ—¶ç¥–çˆ¶èŠ‚ç‚¹å·¦å³å­æ ‘é»‘è‰²èŠ‚ç‚¹é«˜åº¦ä»ç„¶ç›¸åŒï¼Œä¾‹å¦‚ä¸Šå›¾ä¸­çš„ç¬¬5æ£µæ ‘ï¼Œä¹‹åå°†ç¥–çˆ¶èŠ‚ç‚¹ä½œä¸ºæ’å…¥èŠ‚ç‚¹ç»§ç»­å‘ä¸Šæ£€æŸ¥ï¼Œä¸‹é¢çš„ä»£ç æ‰§è¡Œçš„æ­£æ˜¯è¿™ä¸€æ­¥éª¤ï¼š

```c
void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *parent, *gparent;

    while ((parent = node->rb_parent) && parent->rb_color == RB_RED)
    {
        gparent = parent->rb_parent; // ç¥–çˆ¶èŠ‚ç‚¹

        if (parent == gparent->rb_left)
        {
            {
                register struct rb_node *uncle = gparent->rb_right;
                if (uncle && uncle->rb_color == RB_RED)
                {
                    uncle->rb_color = RB_BLACK;
                    parent->rb_color = RB_BLACK;
                    gparent->rb_color = RB_RED;
                    node = gparent;
                    continue;
                }
            }
            ... // å…¶ä»–æ£€æŸ¥å’Œå¤„ç†
        } else {
            {
                register struct rb_node *uncle = gparent->rb_left;
                if (uncle && uncle->rb_color == RB_RED)
                {
                    uncle->rb_color = RB_BLACK;
                    parent->rb_color = RB_BLACK;
                    gparent->rb_color = RB_RED;
                    node = gparent;
                    continue;
                }
            }
            ... // å…¶ä»–æ£€æŸ¥å’Œå¤„ç†
        }
    }

    root->rb_node->rb_color = RB_BLACK;
}
```

ç¬¬ä¸‰ç§æƒ…å†µæœ€ä¸ºå¤æ‚ï¼Œç”±äºå”çˆ¶èŠ‚ç‚¹ä¸å†æ˜¯çº¢è‰²ï¼Œæ•…ä¸èƒ½åªé æŸ“è‰²æ¥è§£å†³ï¼Œå…¶å¯åˆ†ä¸ºä»¥ä¸‹å››ç§ï¼š

1. æ’å…¥èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹ä¸ºç¥–çˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼›
2. æ’å…¥èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹ä¸ºç¥–çˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼›
3. æ’å…¥èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹ä¸ºç¥–çˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼›
4. æ’å…¥èŠ‚ç‚¹ä¸ºçˆ¶èŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹ï¼Œçˆ¶èŠ‚ç‚¹ä¸ºç¥–çˆ¶èŠ‚ç‚¹çš„å³èŠ‚ç‚¹ï¼›

åœ¨è¿™å››ç§ä¸­ï¼Œç¬¬2ç§ï¼ˆå·¦å·¦ï¼‰å’Œç¬¬3ç§ï¼ˆå³å³ï¼‰éœ€è¦å…ˆè¿›è¡Œä¸€æ¬¡æŸ“è‰²è§£å†³è§„åˆ™4å†²çªï¼Œç„¶åç»è¿‡æ—‹è½¬è§£å†³æŸ“è‰²åçš„è§„åˆ™5å†²çªã€‚ä»¥å·¦å·¦ä¸ºä¾‹ï¼Œå…ˆå°†çˆ¶èŠ‚ç‚¹æŸ“æˆé»‘è‰²ï¼Œç¥–çˆ¶èŠ‚ç‚¹æŸ“æˆçº¢è‰²ï¼Œæ­¤æ—¶ä¸å†æœ‰é¢œè‰²å†²çªï¼Œä½†æ˜¯è§„åˆ™5å‡ºç°å†²çªï¼Œå› ä¸ºå·¦å­æ ‘æ˜¾ç„¶å¤šå‡ºä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥ç¥–çˆ¶èŠ‚ç‚¹å³æ—‹ï¼Œå°†çˆ¶èŠ‚ç‚¹ä½œä¸ºç¥–çˆ¶èŠ‚ç‚¹ï¼Œè¿™æ ·å°±å®Œæˆäº†ä¸¤ä¸ªæ°åˆ°å¥½å¤„çš„äº‹æƒ…ï¼š1ï¼‰ç¥–çˆ¶èŠ‚ç‚¹ä½ç½®çš„é¢œè‰²å†æ¬¡å˜ä¸ºé»‘è‰²ï¼Œè¿™å¿…ç„¶ä½¿å¾—ç¥–çˆ¶ä¸ä¼šç ´åè§„åˆ™4ï¼›2ï¼‰ç”±äºåŸç¥–çˆ¶èŠ‚ç‚¹æŸ“æˆçº¢è‰²ï¼Œæ‰€ä»¥å³ä½¿å…¶å˜æˆäº†å³å­æ ‘çš„èŠ‚ç‚¹ä¹Ÿä¸å½±å“è§„åˆ™5ã€‚ä¸‹å›¾å±•ç¤ºäº†è¿™ä¸€è¿‡ç¨‹ï¼š

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240324160538162-1068851558.png)

å¯¹äºå³å³ï¼Œå…¶ä¸å·¦å·¦åŒºåˆ«åœ¨äºä½¿ç”¨å·¦æ—‹ï¼ŒåŸç†å¯ä»¥å‚è€ƒå·¦å·¦è‡ªè¡Œæ¨æ–­ã€‚<br />å¯¹äºç¬¬1ç§ï¼ˆå³å·¦ï¼‰å’Œç¬¬4ç§ï¼ˆå·¦å³ï¼‰ï¼Œéœ€è¦å¤šå¢åŠ ä¸€ä¸ªæ—‹è½¬ï¼Œä½¿å…¶å˜ä¸ºå·¦å·¦æˆ–è€…å³å³ï¼Œç„¶åä¾¿å¯æŒ‰ç…§å·¦å·¦/å³å³çš„è§„åˆ™è°ƒæ•´RB Treeï¼Œä¸‹å›¾å±•ç¤ºäº†å³å·¦çš„è°ƒæ•´è¿‡ç¨‹ã€‚

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240324154716488-957268159.png)

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸è®ºæ˜¯è¿™å››ç§ä¸­çš„å“ªç§ï¼Œæœ€åæ“ä½œçš„ç»“æœå®é™…ä¸Šéƒ½æ˜¯åœ¨ç¥–çˆ¶èŠ‚ç‚¹å’Œå”çˆ¶èŠ‚ç‚¹ç›´æ¥æ–°æ’å…¥äº†çº¢è‰²èŠ‚ç‚¹ï¼Œç¥–çˆ¶èŠ‚ç‚¹é¢œè‰²å¹¶æ²¡æœ‰æ”¹å˜ï¼Œè€Œä¸”é»‘è‰²èŠ‚ç‚¹æ•°é‡ä¹Ÿæ²¡æœ‰æ”¹å˜ï¼Œæ‰€ä»¥åœ¨è°ƒæ•´ç»“æŸåæ— éœ€ç»§ç»­å‘ä¸Šæ£€æŸ¥ã€‚ä¸‹é¢æ˜¯å†…æ ¸ä¸­å…³äºç¬¬ä¸‰ç§æƒ…å†µçš„å¤„ç†ï¼š

```c
static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *right = node->rb_right;

    if ((node->rb_right = right->rb_left))
        right->rb_left->rb_parent = node;
    right->rb_left = node;

    if ((right->rb_parent = node->rb_parent))
    {
        if (node == node->rb_parent->rb_left)
            node->rb_parent->rb_left = right;
        else
            node->rb_parent->rb_right = right;
    }
    else
        root->rb_node = right;
    node->rb_parent = right;
}

static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *left = node->rb_left;

    if ((node->rb_left = left->rb_right))
        left->rb_right->rb_parent = node;
    left->rb_right = node;

    if ((left->rb_parent = node->rb_parent))
    {
        if (node == node->rb_parent->rb_right)
            node->rb_parent->rb_right = left;
        else
            node->rb_parent->rb_left = left;
    }
    else
        root->rb_node = left;
    node->rb_parent = left;
}

void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *parent, *gparent;

    while ((parent = node->rb_parent) && parent->rb_color == RB_RED)
    {
        gparent = parent->rb_parent;

        if (parent == gparent->rb_left)
        {
            {
                register struct rb_node *uncle = gparent->rb_right;
                ... // å”çˆ¶ä¸ºçº¢è‰²çš„å¤„ç†
            }

            if (parent->rb_right == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_left(parent, root);
                tmp = parent; 
                parent = node;
                node = tmp;
            }

            parent->rb_color = RB_BLACK;
            gparent->rb_color = RB_RED;
            __rb_rotate_right(gparent, root);
        } else {
            {
                register struct rb_node *uncle = gparent->rb_left;
                ... // å”çˆ¶ä¸ºçº¢è‰²çš„å¤„ç†
            }

            if (parent->rb_left == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_right(parent, root);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            parent->rb_color = RB_BLACK;
            gparent->rb_color = RB_RED;
            __rb_rotate_left(gparent, root);
        }
    }

    root->rb_node->rb_color = RB_BLACK;
}
```

åœ¨Linuxå†…æ ¸ä¸­ï¼Œå¦‚æœéœ€è¦æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹åˆ°RB Treeä¸­ï¼Œéœ€è¦æ‰§è¡Œä»¥ä¸‹å‡ æ­¥ï¼š

1. éå†RB Treeï¼Œæ‰¾åˆ°æ–°èŠ‚ç‚¹æ’å…¥ä½ç½®ï¼›
2. è°ƒç”¨`rb_link_node`å°†èŠ‚ç‚¹é“¾æ¥åˆ°1æ‰¾åˆ°çš„ä½ç½®ï¼›
3. è°ƒç”¨`rb_insert_color`è°ƒæ•´RB Treeï¼Œä½¿å…¶ç¬¦åˆè§„åˆ™ã€‚

#### 2.2 çº¢é»‘æ ‘çš„èŠ‚ç‚¹åˆ é™¤

çº¢é»‘æ ‘çš„åˆ é™¤æ¯”æ’å…¥æ“ä½œæ›´ä¸ºå¤æ‚ï¼Œå…¶åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œç¬¬ä¸€ä¸ªé˜¶æ®µå…ˆåˆ é™¤èŠ‚ç‚¹ï¼Œå…¶æŠ€å·§ä¸ºï¼šå¦‚æœåˆ é™¤èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå­©å­æˆ–è€…æ²¡å­©å­ï¼Œé‚£ä¹ˆç›´æ¥åˆ é™¤è¯¥èŠ‚ç‚¹ï¼Œå¹¶é“¾æ¥çˆ¶èŠ‚ç‚¹å’Œå­©å­èŠ‚ç‚¹ï¼Œä»£ç å¦‚ä¸‹ï¼š

```c
void rb_erase(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *child, *parent;
    int color;

    if (!node->rb_left)
        child = node->rb_right;
    else if (!node->rb_right)
        child = node->rb_left;
    else
    {
        ... // æœ‰ä¸¤ä¸ªå­©å­çš„æ“ä½œ
    }

    parent = node->rb_parent;
    color = node->rb_color;

    // é“¾æ¥çˆ¶èŠ‚ç‚¹å’Œå­©å­èŠ‚ç‚¹
    if (child)
        child->rb_parent = parent;
    if (parent)
    {
        if (parent->rb_left == node)
            parent->rb_left = child;
        else
            parent->rb_right = child;
    }
    else
        root->rb_node = child;

 color: // ç¬¬äºŒé˜¶æ®µï¼šè°ƒæ•´
    if (color == RB_BLACK)
        __rb_erase_color(child, parent, root);
}
```

å¦‚æœæœ‰ä¸¤ä¸ªå­©å­ï¼Œé‚£ä¹ˆé€‰æ‹©åˆ é™¤èŠ‚ç‚¹çš„é¡ºåºä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ›¿æ¢åˆ é™¤èŠ‚ç‚¹ï¼Œæ—¢åˆ é™¤ä½ç½®å˜åˆ°äº†åˆ é™¤èŠ‚ç‚¹çš„é¡ºåºä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„åŸå…ˆä½ç½®ï¼Œè¿™æ ·å¯ä»¥ä¿è¯åˆ é™¤èŠ‚ç‚¹åªæœ‰ä¸€ä¸ªå³å­æ ‘ï¼ˆå› ä¸ºåˆ é™¤èŠ‚ç‚¹çš„é¡ºåºä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯åˆ é™¤èŠ‚ç‚¹çš„å³å­æ ‘çš„æœ€å·¦è¾¹çš„å¶å­èŠ‚ç‚¹ï¼‰ï¼Œä»£ç å¦‚ä¸‹ï¼š

```c
void rb_erase(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *child, *parent;
    int color;

    if (!node->rb_left)
        ...
    else if (!node->rb_right)
        ...
    else
    {
        struct rb_node *old = node, *left;

        node = node->rb_right;
        while ((left = node->rb_left) != NULL)
            node = left;
        // æ­¤æ—¶ node ä¸º åˆ é™¤èŠ‚ç‚¹çš„é¡ºåºä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆåªæœ‰å³å­æ ‘æˆ–è€…æ— å­©å­ï¼‰ï¼Œold ä¸ºåŸåˆ é™¤èŠ‚ç‚¹
        child = node->rb_right;
        parent = node->rb_parent;
        color = node->rb_color;

        // é“¾æ¥åˆ é™¤èŠ‚ç‚¹çš„é¡ºåºä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹å’Œçˆ¶èŠ‚ç‚¹
        if (child)
            child->rb_parent = parent;
        if (parent)
        {
            if (parent->rb_left == node)
                parent->rb_left = child;
            else
                parent->rb_right = child;
        }
        else
            root->rb_node = child;

        if (node->rb_parent == old) // ç”±äº old æ˜¯å¾…åˆ é™¤èŠ‚ç‚¹ï¼Œè€Œ parent æ­¤æ—¶æŒ‡å‘ oldï¼Œæ‰€ä»¥è¦å°† parent æŒ‡å‘æ–°çš„ node
            parent = node;
        // node èŠ‚ç‚¹æ›¿æ¢åŸåˆ é™¤èŠ‚ç‚¹
        node->rb_parent = old->rb_parent;
        node->rb_color = old->rb_color;
        node->rb_right = old->rb_right;
        node->rb_left = old->rb_left;

        // å°†æ–° node é“¾æ¥åˆ°åŸåˆ é™¤èŠ‚ç‚¹ old çš„çˆ¶èŠ‚ç‚¹ä¸Š
        if (old->rb_parent)
        {
            if (old->rb_parent->rb_left == old)
                old->rb_parent->rb_left = node;
            else
                old->rb_parent->rb_right = node;
        } else
            root->rb_node = node;

        // å°†æ–° node é“¾æ¥åˆ°åŸåˆ é™¤èŠ‚ç‚¹ old çš„å­èŠ‚ç‚¹ä¸Š
        old->rb_left->rb_parent = node;
        if (old->rb_right) // å¯èƒ½åˆ é™¤çš„å³å­æ ‘åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ é™¤åå˜ä¸ºNULL
            old->rb_right->rb_parent = node;
        goto color;
    }

 color: // ç¬¬äºŒé˜¶æ®µï¼šè°ƒæ•´
    if (color == RB_BLACK)
        __rb_erase_color(child, parent, root);
}
```

ç¬¬äºŒé˜¶æ®µ

å½“åœ¨ç¬¬ä¸€é˜¶æ®µç¡®å®šäº†åˆ é™¤èŠ‚ç‚¹ä½ç½®ï¼ˆé€šå¸¸å…¶åªæœ‰ä¸€ä¸ªå­æ ‘æˆ–è€…æ²¡æœ‰å­æ ‘ï¼‰åï¼Œå°†ä¼šæ£€æŸ¥æ˜¯å¦è¦è¿›è¡Œè°ƒè‰²å’Œæ—‹è½¬ä½¿å¾—èŠ‚ç‚¹åˆ é™¤åçš„RB Treeå†æ¬¡ç¬¦åˆè§„åˆ™ã€‚æˆ‘ä»¬åœ¨ä¸‹é¢é€šè¿‡5ç§å¤§çš„æƒ…å†µæ¥è®²è§£è¿™ä¸€æ“ä½œã€‚<br />(1) æœ€ç®€å•çš„æƒ…å†µæ˜¯ï¼šæˆ‘ä»¬åˆ é™¤çš„èŠ‚ç‚¹é¢œè‰²æ˜¯çº¢è‰²çš„ï¼Œè¿™æ„å‘³ç€èŠ‚ç‚¹åˆ é™¤åï¼Œå­æ ‘è¿æ¥åˆ°å…¶çˆ¶èŠ‚ç‚¹åé»‘è‰²èŠ‚ç‚¹é«˜åº¦ä¸å˜ï¼Œå› æ­¤æ— éœ€è°ƒæ•´ï¼Œè¿™ç‚¹å¯ä»¥åœ¨`rb_erase`å‡½æ•°çš„æœ€åå°è¯ï¼Œå› ä¸ºåªæœ‰åˆ é™¤èŠ‚ç‚¹ä¸ºé»‘è‰²æ‰éœ€è¦æ‰§è¡Œ`__rb_erase_color`å‡½æ•°ã€‚

(2) ç¨å¾®å¤æ‚çš„ä¸€ç§æƒ…å†µæ˜¯ï¼šæˆ‘ä»¬åˆ é™¤çš„èŠ‚ç‚¹Bé¢œè‰²æ˜¯é»‘è‰²ï¼ŒåŒæ—¶å…¶çˆ¶èŠ‚ç‚¹çš„å¦ä¸€ä¸ªå­©å­èŠ‚ç‚¹Cé¢œè‰²ä¹Ÿæ˜¯é»‘è‰²ä¸”å…¶å·¦å³å­©å­èŠ‚ç‚¹E/Fä¹Ÿä¸ºé»‘è‰²ã€‚ç”±äºçˆ¶èŠ‚ç‚¹Açš„ä¸€è¾¹å°‘äº†ä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹ï¼Œæ‰€ä»¥åº”è¯¥æŠŠå¦ä¸€è¾¹çš„é»‘è‰²èŠ‚ç‚¹æŸ“æˆçº¢è‰²ï¼Œè¿™æ ·çˆ¶èŠ‚ç‚¹Açš„å·¦å³é»‘è‰²èŠ‚ç‚¹é«˜åº¦ç›¸åŒï¼Œè€Œä¸”Cå’ŒE/FèŠ‚ç‚¹é¢œè‰²ä¸å†²çªã€‚å¯¹äºçˆ¶èŠ‚ç‚¹Aï¼Œå¦‚æœå…¶ä¸ºçº¢è‰²ï¼Œé‚£æ­£å¥½ï¼Œå°†å…¶æŸ“è‰²ä¸ºé»‘è‰²ï¼Œè¿™æ ·ä»¥Aä¸ºæ ¹çš„å­æ ‘é«˜åº¦åˆæ¢å¤åŸæ ·ï¼Œä¸”é¢œè‰²ä¹Ÿä¸ä¼šå†²çªï¼›å¦‚æœAä¸ºé»‘è‰²ï¼Œé‚£ä¹ˆå°±è¦ç»§ç»­å‘ä¸Šæ£€æŸ¥è°ƒæ•´ï¼Œä»£ç å¦‚ä¸‹ï¼š

```c
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,
                 struct rb_root *root)
{
    struct rb_node *other;

    while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
    {
        if (parent->rb_left == node)
        {
            other = parent->rb_right;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                other->rb_color = RB_RED;
                node = parent;
                parent = node->rb_parent;
            }
            else
            {
                ...
            }
        }
        else
        {
            other = parent->rb_left;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                other->rb_color = RB_RED;
                node = parent;
                parent = node->rb_parent;
            }
            else
            {
                ...
            }
        }
    }
    if (node)
        node->rb_color = RB_BLACK;
}
```

ä¸‹é¢ä»¥åˆ é™¤èŠ‚ç‚¹ä¸ºå·¦å­æ ‘ä¸ºä¾‹å±•ç¤ºäº†è°ƒè‰²è¿‡ç¨‹ï¼š<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240331170002381-854800943.png)

(3) æˆ‘ä»¬åˆ é™¤çš„èŠ‚ç‚¹Bé¢œè‰²æ˜¯é»‘è‰²çš„ï¼ŒåŒæ—¶å…¶çˆ¶èŠ‚ç‚¹Açš„å¦ä¸€ä¸ªå­©å­èŠ‚ç‚¹Cé¢œè‰²æ˜¯é»‘è‰²çš„ï¼Œè€ŒCå·¦å­©å­èŠ‚ç‚¹Eä¸ºé»‘è‰²ï¼Œå³å­©å­èŠ‚ç‚¹Fä¸ºçº¢è‰²ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œå¯ä»¥å°†çˆ¶èŠ‚ç‚¹æŸ“è‰²æˆé»‘è‰²å·¦æ—‹/å³æ—‹ä½¿å¾—åˆ é™¤èŠ‚ç‚¹ä¸€ä¾§å¢åŠ ä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹ï¼Œå¯¹äºå¦ä¸€è¾¹ï¼Œå› ä¸ºCå› ä¸ºæ—‹è½¬å˜æˆäº†å­æ ‘æ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥å…¶åº”è¯¥ç»§æ‰¿åŸå…ˆå­æ ‘æ ¹èŠ‚ç‚¹é¢œè‰²ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œç”±äºCä¸å†æ˜¯å­æ ‘èŠ‚ç‚¹ï¼Œæ‰€ä»¥å°‘äº†ä¸€ä¸ªé»‘è‰²èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¦æŠŠFæŸ“æˆé»‘è‰²ï¼Œä»£ç å¦‚ä¸‹ï¼š

```c
static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,
                 struct rb_root *root)
{
    struct rb_node *other;

    while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
    {
        if (parent->rb_left == node)
        {
            other = parent->rb_right;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                ...
            }
            else
            {
                if (!other->rb_right ||
                    other->rb_right->rb_color == RB_BLACK)
                {
                    ...
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_right)
                    other->rb_right->rb_color = RB_BLACK;
                __rb_rotate_left(parent, root);
                node = root->rb_node;
                break;
            }
        }
        else
        {
            other = parent->rb_left;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                ...
            }
            else
            {
                if (!other->rb_left ||
                    other->rb_left->rb_color == RB_BLACK)
                {
                    ...
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_left)
                    other->rb_left->rb_color = RB_BLACK;
                __rb_rotate_right(parent, root);
                node = root->rb_node;
                break;
            }
        }
    }
    if (node)
        node->rb_color = RB_BLACK;
}
```

ä¸‹é¢ä»¥åˆ é™¤èŠ‚ç‚¹ä¸ºå·¦å­æ ‘ä¸ºä¾‹å±•ç¤ºäº†è°ƒè‰²è¿‡ç¨‹ï¼š<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240331170232219-236724999.png)

(4) æˆ‘ä»¬åˆ é™¤çš„èŠ‚ç‚¹Bé¢œè‰²æ˜¯é»‘è‰²çš„ï¼ŒåŒæ—¶å…¶çˆ¶èŠ‚ç‚¹Açš„å¦ä¸€ä¸ªå­©å­èŠ‚ç‚¹Cé¢œè‰²æ˜¯é»‘è‰²çš„ï¼Œè€ŒCå·¦å­©å­èŠ‚ç‚¹Eä¸ºçº¢è‰²ï¼Œå³å­©å­èŠ‚ç‚¹Fä¸ºé»‘è‰²ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œåº”è¯¥å…ˆç»è¿‡æŸ“è‰²å’Œæ—‹è½¬å°†å…¶å˜ä¸ºæƒ…å†µ(3)ã€‚å…¶è¿‡ç¨‹ä¸ºå°†CæŸ“æˆçº¢è‰²å³æ—‹ï¼Œè¿™æ ·CåŸå…ˆè¿™é¢—å­æ ‘å·¦å³å­æ ‘é»‘è‰²èŠ‚ç‚¹é«˜åº¦ä¸å˜ï¼Œåªæ˜¯Cå’ŒEé¢œè‰²å†²çªï¼Œä¸è¿‡è¿™ä¸ç”¨æ‹…å¿ƒï¼ŒæŒ‰ç…§(3)çš„æ–¹æ³•ï¼ŒCæœ€åå˜æˆé»‘è‰²ï¼Œè€ŒEå˜æˆäº†åŸå…ˆAçš„é¢œè‰²ï¼Œä»£ç å¦‚ä¸‹ï¼š

```cstatic
                 struct rb_root *root)
{
    struct rb_node *other;

    while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
    {
        if (parent->rb_left == node)
        {
            other = parent->rb_right;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                ...
            }
            else
            {
                if (!other->rb_right ||
                    other->rb_right->rb_color == RB_BLACK)
                {
                    register struct rb_node *o_left;
                    if ((o_left = other->rb_left))
                        o_left->rb_color = RB_BLACK;
                    other->rb_color = RB_RED;
                    __rb_rotate_right(other, root);
                    other = parent->rb_right;
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_right)
                    other->rb_right->rb_color = RB_BLACK;
                __rb_rotate_left(parent, root);
                node = root->rb_node;
                break;
            }
        }
        else
        {
            other = parent->rb_left;
            if (other->rb_color == RB_RED)
            {
                ...
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                ...
            }
            else
            {
                if (!other->rb_left ||
                    other->rb_left->rb_color == RB_BLACK)
                {
                    register struct rb_node *o_right;
                    if ((o_right = other->rb_right))
                        o_right->rb_color = RB_BLACK;
                    other->rb_color = RB_RED;
                    __rb_rotate_left(other, root);
                    other = parent->rb_left;
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_left)
                    other->rb_left->rb_color = RB_BLACK;
                __rb_rotate_right(parent, root);
                node = root->rb_node;
                break;
            }
        }
    }
    if (node)
        node->rb_color = RB_BLACK;
}
```

ä¸‹é¢ä»¥åˆ é™¤èŠ‚ç‚¹ä¸ºå·¦å­æ ‘ä¸ºä¾‹å±•ç¤ºäº†è°ƒè‰²è¿‡ç¨‹ï¼š<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240331172122810-1623435620.png)

(5) æˆ‘ä»¬åˆ é™¤çš„èŠ‚ç‚¹Bé¢œè‰²æ˜¯é»‘è‰²çš„ï¼ŒåŒæ—¶å…¶çˆ¶èŠ‚ç‚¹Açš„å¦ä¸€ä¸ªå­©å­èŠ‚ç‚¹Cé¢œè‰²æ˜¯çº¢è‰²çš„ã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œæ„å‘³ç€çˆ¶èŠ‚ç‚¹Aå¿…å®šä¸ºé»‘è‰²çš„ï¼Œè€ŒCçš„E/Få­©å­èŠ‚ç‚¹ä¸ºé»‘è‰²çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†AæŸ“æˆçº¢è‰²å·¦æ—‹/å³æ—‹ï¼Œç„¶åCæŸ“æˆé»‘è‰²ï¼Œè¿™æ ·ï¼Œè¿™é¢—å­æ ‘é»‘è‰²èŠ‚ç‚¹é«˜åº¦ä¸å˜ï¼ŒåŒæ—¶åˆ é™¤èŠ‚ç‚¹ä¸€ä¾§çš„å­æ ‘å˜æˆäº†(3)æˆ–è€…(4)çš„æƒ…å†µï¼Œå› ä¸ºç»è¿‡æ—‹è½¬ï¼ŒAçš„å³èŠ‚ç‚¹å˜æˆäº†é»‘è‰²ï¼Œä»£ç å¦‚ä¸‹ï¼š

```cstatic
                 struct rb_root *root)
{
    struct rb_node *other;

    while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
    {
        if (parent->rb_left == node)
        {
            other = parent->rb_right;
            if (other->rb_color == RB_RED)
            {
                other->rb_color = RB_BLACK;
                parent->rb_color = RB_RED;
                __rb_rotate_left(parent, root);
                other = parent->rb_right;
            }
            ...
        }
        else
        {
            other = parent->rb_left;
            if (other->rb_color == RB_RED)
            {
                other->rb_color = RB_BLACK;
                parent->rb_color = RB_RED;
                __rb_rotate_right(parent, root);
                other = parent->rb_left;
            }
            ...
        }
    }
    if (node)
        node->rb_color = RB_BLACK;
}
```

ä¸‹é¢ä»¥åˆ é™¤èŠ‚ç‚¹ä¸ºå·¦å­æ ‘ä¸ºä¾‹å±•ç¤ºäº†è°ƒè‰²è¿‡ç¨‹ï¼š<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240331170407070-1560007634.png)

#### 2.3 çº¢é»‘æ ‘çš„æŸ¥è¯¢æ“ä½œ

Linuxå†…æ ¸ä¸­çº¢é»‘æ ‘åº“æä¾›çš„åŠŸèƒ½æ²¡æœ‰ç‰¹å®šæŸä¸€ç§æ’åºæ–¹æ³•ï¼Œæ‰€ä»¥ä¹Ÿæ²¡æœ‰ç»™å‡ºæŸ¥è¯¢æ¥å£ã€‚ç”±äºçº¢é»‘æ ‘ä¹Ÿæ˜¯äºŒå‰æ’åºæ ‘çš„ä¸€ç§ï¼Œä»¥å‡åºä¸ºä¾‹ï¼Œæˆ‘ä»¬åªéœ€è¦æŒ‰ç…§ä»¥ä¸‹æµç¨‹å³å¯è¿›è¡ŒæŸ¥è¯¢æ“ä½œï¼š

```python
Query x:

node = root
while node is not null and node.value != x:
    if node.value < xï¼š
        node = node.right
    else:
        node = node.left

Return node
```

### 3. çº¢é»‘æ ‘æ“ä½œå®éªŒ

> å®éªŒä»‹ç»ï¼šæœ‰ä¸€ç§å¯¹è±¡Itemï¼Œé‡Œé¢åŒ…å«ï¼š1ï¼‰æ ‘èŠ‚ç‚¹ï¼Œç”¨äºç®¡ç†RB Treeï¼›2ï¼‰æ•°å€¼ï¼Œè¡¨ç¤ºäº†å¯¹è±¡çš„å®é™…å†…å®¹ï¼›3ï¼‰å‡ºç°æ¬¡æ•°ï¼Œç”±äºæˆ‘ä»¬å¸Œæœ›èŠ‚ç‚¹éšæœºäº§ç”Ÿï¼Œå› æ­¤å¯èƒ½å­˜åœ¨é‡å¤çš„æƒ…å†µï¼Œè¯¥å€¼ç”¨äºç»Ÿè®¡ç›¸åŒèŠ‚ç‚¹çš„æ•°é‡ã€‚æˆ‘ä»¬å…ˆéšæœºnumä¸ªItemï¼Œç„¶åä½¿ç”¨è¿™äº›Itemæ„å»ºå‡ºçº¢é»‘æ ‘ã€‚æœ€åé€šè¿‡è¾“å…¥è¦æ“¦é™¤çš„å¯¹è±¡ï¼Œæˆ‘ä»¬å°†å…¶ä»æ ‘ä¸­åˆ é™¤å¹¶æ˜¾ç¤ºã€‚

ä¸‹å›¾æ—¶ä»£ç è¿è¡Œåçš„æ•ˆæœï¼Œæ¯ä¸ªèŠ‚ç‚¹æ‰“å°å«ä¹‰ä¸º`[æ•°å€¼ï¼Œå‡ºç°æ¬¡æ•°ï¼ŒèŠ‚ç‚¹é¢œè‰²]`ï¼Œæœ€å·¦è¾¹ä¸ºæ ¹èŠ‚ç‚¹ï¼Œå·¦èŠ‚ç‚¹åœ¨å³èŠ‚ç‚¹ä¸Šæ–¹ã€‚<br />

![](https://raw.githubusercontent.com/mengchao666/picture/main/blog1949124-20240331141025628-1498122160.png)

### é™„å½•A: å®éªŒä»£ç 

```c
main.c :

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "rbtree.h"

typedef struct _Item
{
    int val;
    int num; // appear num
    struct rb_node node;
}Item;

static int print_num = 0;
static int print_level = 0;

Item* GenerateItem();
void DFS(struct rb_node *node);

int main()
{
    int num = 0;
    Item *item, *cur, *prev = NULL;
    struct rb_node **link;
    struct rb_root root = RB_ROOT;
  
    srand(time(NULL));

    printf("Test item num: ");
    scanf("%d", &num);
  
    print_num = 0;
    printf("Generate Item[%d]:\n", num);
    /* generate a random rb tree with [num] node */
    while (num > 0)
    {
        /* randomize a rb tree node */
        item = GenerateItem();
        if (print_num == 16)
        {
            printf("\n");
            print_num = 0;
        }
        printf("%d\t", item->val);

        /* insert a rb tree node to rb tree */
        if (!root.rb_node) // empty rb tree
        {
            root.rb_node = &(item->node);
            rb_insert_color(&(item->node), &root);
            goto next_loop;
        }
        cur = rb_entry(root.rb_node, Item, node);
        /* 1. find insert position */
        while (cur)
        {
            if (cur->val == item->val) // the same item
            {
                cur->num++;
                free(item);
                goto next_loop;
            }
            else if (cur->val > item->val)
            {
                prev = cur;
                link = &(cur->node.rb_left);
                if (cur->node.rb_left == NULL)
                {
                    break;
                }
                cur = rb_entry(cur->node.rb_left, Item, node);
            }
            else
            {
                prev = cur;
                link = &(cur->node.rb_right);
                if (cur->node.rb_right == NULL)
                {
                    break;
                }
                cur = rb_entry(cur->node.rb_right, Item, node);
            }
        }
        /* 2. link node */
        rb_link_node(&(item->node), &(prev->node), link);
        /* 3. adjust */
        rb_insert_color(&(item->node), &root);
next_loop:
        num--;
    }
  
    /* print a generated rb tree */
    print_num = 0;
    print_level = 0;
    printf("\nsort result:\n");
    DFS(root.rb_node);
    printf("\n");

    /* testing erase some rb tree node */
    printf("\nTest Erase, input node value to erase its node, or input negative value to exit\n");
    while (1)
    {
        /* get the node need to erase */
        printf(">>");
        scanf("%d", &num);
        if (num < 0)
        {
            break;
        }
        /* 1. find insert position */
        if (!root.rb_node) // empty rb tree
        {
            printf("empty tree\n");
            break;
        }
        cur = rb_entry(root.rb_node, Item, node);
        while (cur)
        {
            if (cur->val == num) // the same item
            {
                break;
            }
            else if (cur->val > num)
            {
                if (cur->node.rb_left == NULL)
                {
                    cur = NULL;
                    break;
                }
                cur = rb_entry(cur->node.rb_left, Item, node);
            }
            else
            {
                if (cur->node.rb_right == NULL)
                {
                    cur = NULL;
                    break;
                }
                cur = rb_entry(cur->node.rb_right, Item, node);
            }
        }
        /* 2. do erase function */
        if (cur)
        {
            printf("erase %d\n", num);
            rb_erase(&(cur->node), &root);
            free(cur);
            DFS(root.rb_node);
            printf("\n");
        }
        else
        {
            printf("not exist\n");
        }
        printf("===================================================================\n");
    }
  
    return 0;
}

Item* GenerateItem()
{
    Item *item = (Item*)malloc(sizeof(Item));
  
    item->val = rand() % 1000;
    item->num = 1;
  
    item->node.rb_parent = NULL;
    item->node.rb_left = NULL;
    item->node.rb_right = NULL;
  
    return item;
}

void DFS(struct rb_node *node)
{
    Item *item;
    int i;
  
    if (node)
    {
        print_level++;
        DFS(node->rb_left);
        if (print_num == 4)
        {
            printf("\n");
            print_num = 0;
        }
        item = rb_entry(node, Item, node);
        for (i = 1; i < print_level; i++)
        {
            printf("            ");
        }
        printf("[%3d,%3d,%c]\n", item->val, item->num, (item->node.rb_color == RB_RED) ? 'R' : 'B');
        print_num++;
        DFS(node->rb_right);
        print_level--;
    }
}

rbtree.h :
/*
  Red Black Trees
  (C) 1999  Andrea Arcangeli <andrea@suse.de>
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  linux/include/linux/rbtree.h

  To use rbtrees you'll have to implement your own insert and search cores.
  This will avoid us to use callbacks and to drop drammatically performances.
  I know it's not the cleaner way,  but in C (not in C++) to get
  performances and genericity...

  Some example of insert and search follows here. The search is a plain
  normal search over an ordered tree. The insert instead must be implemented
  int two steps: as first thing the code must insert the element in
  order as a red leaf in the tree, then the support library function
  rb_insert_color() must be called. Such function will do the
  not trivial work to rebalance the rbtree if necessary.

-----------------------------------------------------------------------
static inline struct page * rb_search_page_cache(struct inode * inode,
                         unsigned long offset)
{
    struct rb_node * n = inode->i_rb_page_cache.rb_node;
    struct page * page;

    while (n)
    {
        page = rb_entry(n, struct page, rb_page_cache);

        if (offset < page->offset)
            n = n->rb_left;
        else if (offset > page->offset)
            n = n->rb_right;
        else
            return page;
    }
    return NULL;
}

static inline struct page * __rb_insert_page_cache(struct inode * inode,
                           unsigned long offset,
                           struct rb_node * node)
{
    struct rb_node ** p = &inode->i_rb_page_cache.rb_node;
    struct rb_node * parent = NULL;
    struct page * page;

    while (*p)
    {
        parent = *p;
        page = rb_entry(parent, struct page, rb_page_cache);

        if (offset < page->offset)
            p = &(*p)->rb_left;
        else if (offset > page->offset)
            p = &(*p)->rb_right;
        else
            return page;
    }

    rb_link_node(node, parent, p);

    return NULL;
}

static inline struct page * rb_insert_page_cache(struct inode * inode,
                         unsigned long offset,
                         struct rb_node * node)
{
    struct page * ret;
    if ((ret = __rb_insert_page_cache(inode, offset, node)))
        goto out;
    rb_insert_color(node, &inode->i_rb_page_cache);
 out:
    return ret;
}
-----------------------------------------------------------------------
*/

#ifndef    _LINUX_RBTREE_H
#define    _LINUX_RBTREE_H

// #include <linux/kernel.h>
// #include <linux/stddef.h>
#include <stdlib.h>

#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE*)0)->MEMBER)
#define container_of(ptr, type, member) ({            \
        const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
        (type *)( (char *)__mptr - offsetof(type,member) );})

struct rb_node
{
    struct rb_node *rb_parent;
    int rb_color;
#define    RB_RED        0
#define    RB_BLACK    1
    struct rb_node *rb_right;
    struct rb_node *rb_left;
};

struct rb_root
{
    struct rb_node *rb_node;
};

#define RB_ROOT    (struct rb_root) { NULL, }
#define    rb_entry(ptr, type, member) container_of(ptr, type, member)

extern void rb_insert_color(struct rb_node *, struct rb_root *);
extern void rb_erase(struct rb_node *, struct rb_root *);

/* Find logical next and previous nodes in a tree */
extern struct rb_node *rb_next(struct rb_node *);
extern struct rb_node *rb_prev(struct rb_node *);
extern struct rb_node *rb_first(struct rb_root *);
extern struct rb_node *rb_last(struct rb_root *);

/* Fast replacement of a single node without remove/rebalance/add/rebalance */
extern void rb_replace_node(struct rb_node *victim, struct rb_node *new, 
                struct rb_root *root);

static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,
                struct rb_node ** rb_link)
{
    node->rb_parent = parent;
    node->rb_color = RB_RED;
    node->rb_left = node->rb_right = NULL;

    *rb_link = node;
}

#endif    /* _LINUX_RBTREE_H */

rbtree.c :
/*
  Red Black Trees
  (C) 1999  Andrea Arcangeli <andrea@suse.de>
  (C) 2002  David Woodhouse <dwmw2@infradead.org>
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  linux/lib/rbtree.c
*/

// #include <linux/rbtree.h>
// #include <linux/module.h>
#include "rbtree.h"

static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *right = node->rb_right;

    if ((node->rb_right = right->rb_left))
        right->rb_left->rb_parent = node;
    right->rb_left = node;

    if ((right->rb_parent = node->rb_parent))
    {
        if (node == node->rb_parent->rb_left)
            node->rb_parent->rb_left = right;
        else
            node->rb_parent->rb_right = right;
    }
    else
        root->rb_node = right;
    node->rb_parent = right;
}

static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *left = node->rb_left;

    if ((node->rb_left = left->rb_right))
        left->rb_right->rb_parent = node;
    left->rb_right = node;

    if ((left->rb_parent = node->rb_parent))
    {
        if (node == node->rb_parent->rb_right)
            node->rb_parent->rb_right = left;
        else
            node->rb_parent->rb_left = left;
    }
    else
        root->rb_node = left;
    node->rb_parent = left;
}

void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *parent, *gparent;

    while ((parent = node->rb_parent) && parent->rb_color == RB_RED)
    {
        gparent = parent->rb_parent;

        if (parent == gparent->rb_left)
        {
            {
                register struct rb_node *uncle = gparent->rb_right;
                if (uncle && uncle->rb_color == RB_RED)
                {
                    uncle->rb_color = RB_BLACK;
                    parent->rb_color = RB_BLACK;
                    gparent->rb_color = RB_RED;
                    node = gparent;
                    continue;
                }
            }

            if (parent->rb_right == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_left(parent, root);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            parent->rb_color = RB_BLACK;
            gparent->rb_color = RB_RED;
            __rb_rotate_right(gparent, root);
        } else {
            {
                register struct rb_node *uncle = gparent->rb_left;
                if (uncle && uncle->rb_color == RB_RED)
                {
                    uncle->rb_color = RB_BLACK;
                    parent->rb_color = RB_BLACK;
                    gparent->rb_color = RB_RED;
                    node = gparent;
                    continue;
                }
            }

            if (parent->rb_left == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_right(parent, root);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            parent->rb_color = RB_BLACK;
            gparent->rb_color = RB_RED;
            __rb_rotate_left(gparent, root);
        }
    }

    root->rb_node->rb_color = RB_BLACK;
}

static void __rb_erase_color(struct rb_node *node, struct rb_node *parent,
                 struct rb_root *root)
{
    struct rb_node *other;

    while ((!node || node->rb_color == RB_BLACK) && node != root->rb_node)
    {
        if (parent->rb_left == node)
        {
            other = parent->rb_right;
            if (other->rb_color == RB_RED)
            {
                other->rb_color = RB_BLACK;
                parent->rb_color = RB_RED;
                __rb_rotate_left(parent, root);
                other = parent->rb_right;
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                other->rb_color = RB_RED;
                node = parent;
                parent = node->rb_parent;
            }
            else
            {
                if (!other->rb_right ||
                    other->rb_right->rb_color == RB_BLACK)
                {
                    register struct rb_node *o_left;
                    if ((o_left = other->rb_left))
                        o_left->rb_color = RB_BLACK;
                    other->rb_color = RB_RED;
                    __rb_rotate_right(other, root);
                    other = parent->rb_right;
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_right)
                    other->rb_right->rb_color = RB_BLACK;
                __rb_rotate_left(parent, root);
                node = root->rb_node;
                break;
            }
        }
        else
        {
            other = parent->rb_left;
            if (other->rb_color == RB_RED)
            {
                other->rb_color = RB_BLACK;
                parent->rb_color = RB_RED;
                __rb_rotate_right(parent, root);
                other = parent->rb_left;
            }
            if ((!other->rb_left ||
                 other->rb_left->rb_color == RB_BLACK)
                && (!other->rb_right ||
                other->rb_right->rb_color == RB_BLACK))
            {
                other->rb_color = RB_RED;
                node = parent;
                parent = node->rb_parent;
            }
            else
            {
                if (!other->rb_left ||
                    other->rb_left->rb_color == RB_BLACK)
                {
                    register struct rb_node *o_right;
                    if ((o_right = other->rb_right))
                        o_right->rb_color = RB_BLACK;
                    other->rb_color = RB_RED;
                    __rb_rotate_left(other, root);
                    other = parent->rb_left;
                }
                other->rb_color = parent->rb_color;
                parent->rb_color = RB_BLACK;
                if (other->rb_left)
                    other->rb_left->rb_color = RB_BLACK;
                __rb_rotate_right(parent, root);
                node = root->rb_node;
                break;
            }
        }
    }
    if (node)
        node->rb_color = RB_BLACK;
}

void rb_erase(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *child, *parent;
    int color;

    if (!node->rb_left)
        child = node->rb_right;
    else if (!node->rb_right)
        child = node->rb_left;
    else
    {
        struct rb_node *old = node, *left;

        node = node->rb_right;
        while ((left = node->rb_left) != NULL)
            node = left;
        child = node->rb_right;
        parent = node->rb_parent;
        color = node->rb_color;

        if (child)
            child->rb_parent = parent;
        if (parent)
        {
            if (parent->rb_left == node)
                parent->rb_left = child;
            else
                parent->rb_right = child;
        }
        else
            root->rb_node = child;

        if (node->rb_parent == old)
            parent = node;
        node->rb_parent = old->rb_parent;
        node->rb_color = old->rb_color;
        node->rb_right = old->rb_right;
        node->rb_left = old->rb_left;

        if (old->rb_parent)
        {
            if (old->rb_parent->rb_left == old)
                old->rb_parent->rb_left = node;
            else
                old->rb_parent->rb_right = node;
        } else
            root->rb_node = node;

        old->rb_left->rb_parent = node;
        if (old->rb_right)
            old->rb_right->rb_parent = node;
        goto color;
    }

    parent = node->rb_parent;
    color = node->rb_color;

    if (child)
        child->rb_parent = parent;
    if (parent)
    {
        if (parent->rb_left == node)
            parent->rb_left = child;
        else
            parent->rb_right = child;
    }
    else
        root->rb_node = child;

 color:
    if (color == RB_BLACK)
        __rb_erase_color(child, parent, root);
}

/*
 * This function returns the first node (in sort order) of the tree.
 */
struct rb_node *rb_first(struct rb_root *root)
{
    struct rb_node  *n;

    n = root->rb_node;
    if (!n)
        return NULL;
    while (n->rb_left)
        n = n->rb_left;
    return n;
}

struct rb_node *rb_last(struct rb_root *root)
{
    struct rb_node  *n;

    n = root->rb_node;
    if (!n)
        return NULL;
    while (n->rb_right)
        n = n->rb_right;
    return n;
}

struct rb_node *rb_next(struct rb_node *node)
{
    /* If we have a right-hand child, go down and then left as far
       as we can. */
    if (node->rb_right) {
        node = node->rb_right; 
        while (node->rb_left)
            node=node->rb_left;
        return node;
    }

    /* No right-hand children.  Everything down and left is
       smaller than us, so any 'next' node must be in the general
       direction of our parent. Go up the tree; any time the
       ancestor is a right-hand child of its parent, keep going
       up. First time it's a left-hand child of its parent, said
       parent is our 'next' node. */
    while (node->rb_parent && node == node->rb_parent->rb_right)
        node = node->rb_parent;

    return node->rb_parent;
}

struct rb_node *rb_prev(struct rb_node *node)
{
    /* If we have a left-hand child, go down and then right as far
       as we can. */
    if (node->rb_left) {
        node = node->rb_left; 
        while (node->rb_right)
            node=node->rb_right;
        return node;
    }

    /* No left-hand children. Go up till we find an ancestor which
       is a right-hand child of its parent */
    while (node->rb_parent && node == node->rb_parent->rb_left)
        node = node->rb_parent;

    return node->rb_parent;
}

void rb_replace_node(struct rb_node *victim, struct rb_node *new,
             struct rb_root *root)
{
    struct rb_node *parent = victim->rb_parent;

    /* Set the surrounding nodes to point to the replacement */
    if (parent) {
        if (victim == parent->rb_left)
            parent->rb_left = new;
        else
            parent->rb_right = new;
    } else {
        root->rb_node = new;
    }
    if (victim->rb_left)
        victim->rb_left->rb_parent = new;
    if (victim->rb_right)
        victim->rb_right->rb_parent = new;

    /* Copy the pointers/colour from the victim to the replacement */
    *new = *victim;
}
```